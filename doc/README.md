# AVR-Avogadro

**AVR-Avogadro** is another AVR simulator, written in  Rust and C++. There are tons of AVR simulators, some of them are faster, with more features and stuff, so I'll try to do something that programmers usually avoid: Document!


## Technical overview

**AVR-Avogadro** starts in `main.rs`, an instance of Mcu is built with McuFactory, and Qt's GUI engine is initialized. After Qt and Logger are initialized, a C++ function called `run_avogadro_gui` starts the UI.

Qt is mostly event-driven, it doesn't have much logic, instead it just calls the previous MCU methods using *FFI*. This methods can be seen in `src/ffi/mcu_wrapper.rs` file. This "wrapper" is full of extern "C" functions, which receive a pointer Rust MCU object. This MCU is the same we instatiated at `main.rs`, so we can unsafely reconvert it to a Rust object and call its methods


## Library model

### The MCU

`MCU` has two main components: `RegisterBank` and `MemoryBank`. `RegisterBank` is soon to be deprecated, because general purpouse registers should be memory mapped and placed in `MemoryBank`. `MemoryBank` contains *program memory* and *data memory*. *Program memory* is where our executable code lives, while *data memory* is where our *general purpouse registers*, *I/O registers* and stack lives.

### Running a program

We can run a program loading it into the *program memory* by calling `mcu_load_program_memory`. We just load some precompiled binary file (the ones generated by avr-gcc). Once it's loaded, we can run step by step our program (or run N steps). We make a step by calling `mcu_step`. Everytime a step is made, we fetch an instruction from the *memory bank*, and decode it.

### Decoding instructions

We use an enum called `Instruction` for decoding and executing instructions. This enum is declared in `src/core/mod.rs` (Should it be somewhere else?). In `decoder.rs` we declare a `decode(u16)` that returns a Instruction enum.  `decode()` is split into several functions, which are distributed in the `alu` mod. It might not be efficient (I guess compiler will do it's best) but it's quite readable.

Every time `mcu_step` gets called, a "raw instruction" (an u16 integer) is fetch from program memory, decoded into an Instruction enum and finally executed with `Alu::execute`. This function, in `src/core/alu/mod.rs`, matches the current Instruction with it's designed function. Most of them need MemoryBank access to read or change registers or data memory.

Instruction implementations are distributed in the `alu` module, but display formatting is centered in `display_instruction.rs`.
